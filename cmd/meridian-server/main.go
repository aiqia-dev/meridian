package main

import (
	"flag"
	"fmt"
	"io"
	"net"
	"net/http"
	_ "net/http/pprof"
	"os"
	"os/signal"
	"path/filepath"
	"runtime"
	"runtime/pprof"
	"strconv"
	"strings"
	"sync"
	"syscall"

	"github.com/joho/godotenv"
	"github.com/tidwall/gjson"
	"github.com/aiqia-dev/meridian/core"
	"github.com/aiqia-dev/meridian/internal/hservice"
	"github.com/aiqia-dev/meridian/internal/log"
	"github.com/aiqia-dev/meridian/internal/server"

	"golang.org/x/net/context"
	"google.golang.org/grpc"
)

// getEnv returns the value of an environment variable or a default value
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// getEnvInt returns the value of an environment variable as int or a default value
func getEnvInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if i, err := strconv.Atoi(value); err == nil {
			return i
		}
	}
	return defaultValue
}

// getEnvBool returns the value of an environment variable as bool or a default value
func getEnvBool(key string, defaultValue bool) bool {
	if value := os.Getenv(key); value != "" {
		switch strings.ToLower(value) {
		case "1", "true", "yes":
			return true
		case "0", "false", "no":
			return false
		}
	}
	return defaultValue
}

// TODO: Set to false in 2.*
var httpTransport = true

////////////////////////////////////////////////////////////////////////////////
//
// Fire up a webhook test server by using the --webhook-http-consumer-port
// for example
//   $ ./meridian-server --webhook-http-consumer-port 9999
//
// The create hooks like such...
//   SETHOOK myhook http://localhost:9999/myhook NEARBY mykey FENCE POINT 33.5 -115.5 1000
//
////////////////////////////////////////////////////////////////////////////////
//
// Memory profiling - start the server with the -pprofport flag
//
//   $ ./meridian-server -pprofport 6060
//
// Then, at any point, from a different terminal execute:
//   $ go tool pprof -svg http://localhost:6060/debug/pprof/heap > out.svg
//
// Load the SVG into a web browser to visualize the memory usage
//
////////////////////////////////////////////////////////////////////////////////

type hserver struct{}

func (s *hserver) Send(ctx context.Context, in *hservice.MessageRequest) (*hservice.MessageReply, error) {
	return &hservice.MessageReply{Ok: true}, nil
}

func main() {
	// Load .env file if it exists (silent fail if not found)
	_ = godotenv.Load()

	gitsha := " (" + core.GitSHA + ")"
	if gitsha == " (0000000)" {
		gitsha = ""
	}
	versionLine := `meridian-server version: ` + core.Version + gitsha

	output := os.Stderr
	flag.Usage = func() {
		fmt.Fprintf(output,
			"%s", versionLine+`

Usage: meridian-server [-p port]

Basic Options:
  -h hostname : listening host
  -p port     : listening port (default: 9851)
  -d path     : data directory (default: data)
  -s socket   : listen on unix socket file
  -l encoding : set log encoding to json or text (default: text)
  -o output   : auto set client output to json or resp (default: resp)
  -q          : no logging. totally silent output
  -v          : enable verbose logging
  -vv         : enable very verbose logging

Advanced Options:
  --pidfile path          : file that contains the pid
  --appendonly yes/no     : AOF persistence (default: yes)
  --appendfilename path   : AOF path (default: data/appendonly.aof)
  --queuefilename path    : Event queue path (default:data/queue.db)
  --http-transport yes/no : HTTP transport (default: yes)
  --protected-mode yes/no : protected mode (default: yes)
  --nohup                 : do not exit on SIGHUP
  --spinlock              : use a spinlock. For very write-heavy workloads

Developer Options:
  --dev                             : enable developer mode
  --webhook-http-consumer-port port : Start a test HTTP webhook server
  --webhook-grpc-consumer-port port : Start a test GRPC webhook server

Environment Variables (can also be set in .env file):
  MERIDIAN_HOST           : listening host
  MERIDIAN_PORT           : listening port
  MERIDIAN_DIR            : data directory
  MERIDIAN_MAXMEMORY      : maximum memory limit (e.g., 1gb, 512mb)
  MERIDIAN_REQUIREPASS    : authentication password
  MERIDIAN_PROTECTED_MODE : yes/no
  MERIDIAN_APPENDONLY     : yes/no

`,
		)
	}

	if len(os.Args) == 3 && os.Args[1] == "--webhook-http-consumer-port" {
		log.SetOutput(os.Stderr)
		port, err := strconv.ParseUint(os.Args[2], 10, 16)
		if err != nil {
			log.Fatal(err)
		}
		http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
			data, err := io.ReadAll(r.Body)
			if err != nil {
				log.Fatal(err)
			}
			log.HTTPf("http: %s : %s", r.URL.Path, string(data))
		})
		log.Infof("webhook server http://localhost:%d/", port)
		if err := http.ListenAndServe(fmt.Sprintf(":%d", port), nil); err != nil {
			log.Fatal(err)
		}
		return
	}

	if len(os.Args) == 3 && os.Args[1] == "--webhook-grpc-consumer-port" {
		log.SetOutput(os.Stderr)
		port, err := strconv.ParseUint(os.Args[2], 10, 16)
		if err != nil {
			log.Fatal(err)
		}

		lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
		if err != nil {
			log.Fatal(err)
		}
		s := grpc.NewServer()
		hservice.RegisterHookServiceServer(s, &hserver{})
		log.Infof("webhook server grpc://localhost:%d/", port)
		if err := s.Serve(lis); err != nil {
			log.Fatal(err)
		}
		return
	}

	var (
		nohup               bool
		showEvioDisabled    bool
		showThreadsDisabled bool
		spinlock            bool
	)

	var (
		// use to be in core/options.go

		// DevMode puts application in to dev mode
		devMode = false

		// ShowDebugMessages allows for log.Debug to print to console.
		showDebugMessages = false

		// ProtectedMode forces Meridian to default in protected mode.
		protectedMode = getEnv("MERIDIAN_PROTECTED_MODE", "no")

		// AppendOnly allows for disabling the appendonly file.
		appendOnly = getEnvBool("MERIDIAN_APPENDONLY", true)

		// AppendFileName allows for custom appendonly file path
		appendFileName = ""

		// QueueFileName allows for custom queue.db file path
		queueFileName = ""

		// ClientOutput for auto assigning the output for client.
		clientOutput = ""
	)

	// parse non standard args.
	nargs := []string{os.Args[0]}
	for i := 1; i < len(os.Args); i++ {
		switch os.Args[i] {
		case "--help":
			output = os.Stdout
			flag.Usage()
			return
		case "--version":
			fmt.Fprintf(os.Stdout, "%s\n", versionLine)
			return
		case "--protected-mode", "-protected-mode":
			i++
			if i < len(os.Args) {
				switch strings.ToLower(os.Args[i]) {
				case "no":
					protectedMode = "no"
					continue
				case "yes":
					protectedMode = "yes"
					continue
				}
			}
			fmt.Fprintf(os.Stderr, "protected-mode must be 'yes' or 'no'\n")
			os.Exit(1)
		case "--dev", "-dev":
			devMode = true
			continue
		case "--nohup", "-nohup":
			nohup = true
			continue
		case "--spinlock", "-spinlock":
			spinlock = true
			continue
		case "--appendonly", "-appendonly":
			i++
			if i < len(os.Args) {
				switch strings.ToLower(os.Args[i]) {
				case "no":
					appendOnly = false
					continue
				case "yes":
					appendOnly = true
					continue
				}
			}
			fmt.Fprintf(os.Stderr, "appendonly must be 'yes' or 'no'\n")
			os.Exit(1)
		case "--appendfilename", "-appendfilename":
			i++
			if i == len(os.Args) || os.Args[i] == "" {
				fmt.Fprintf(os.Stderr, "appendfilename must have a value\n")
				os.Exit(1)
			}
			appendFileName = os.Args[i]
		case "--queuefilename", "-queuefilename":
			i++
			if i == len(os.Args) || os.Args[i] == "" {
				fmt.Fprintf(os.Stderr, "queuefilename must have a value\n")
				os.Exit(1)
			}
			queueFileName = os.Args[i]
		case "-o":
			i++
			if i < len(os.Args) {
				switch strings.ToLower(os.Args[i]) {
				case "resp", "json":
					clientOutput = strings.ToLower(os.Args[i])
					continue
				}
			}
			fmt.Fprintf(os.Stderr, "output must be 'resp' or 'json'\n")
			os.Exit(1)
		case "--http-transport", "-http-transport":
			i++
			if i < len(os.Args) {
				switch strings.ToLower(os.Args[i]) {
				case "1", "true", "yes":
					httpTransport = true
					continue
				case "0", "false", "no":
					httpTransport = false
					continue
				}
			}
			fmt.Fprintf(os.Stderr, "http-transport must be 'yes' or 'no'\n")
			os.Exit(1)
		case "--threads", "-threads":
			i++
			if i < len(os.Args) {
				_, err := strconv.ParseUint(os.Args[i], 10, 16)
				if err != nil {
					fmt.Fprintf(os.Stderr, "threads must be a valid number\n")
					os.Exit(1)
				}
				showThreadsDisabled = true
				continue
			}
			fmt.Fprintf(os.Stderr, "threads must be a valid number \n")
			os.Exit(1)
		case "--evio", "-evio":
			i++
			if i < len(os.Args) {
				switch strings.ToLower(os.Args[i]) {
				case "no", "yes":
					showEvioDisabled = true
					continue
				}
			}
			fmt.Fprintf(os.Stderr, "evio must be 'yes' or 'no'\n")
			os.Exit(1)
		default:
			nargs = append(nargs, os.Args[i])
		}
	}
	os.Args = nargs

	metricsAddr := flag.String("metrics-addr", getEnv("MERIDIAN_METRICS_ADDR", ""), "The listening addr for Prometheus metrics.")

	var (
		dir            string
		port           int
		host           string
		unixSocket     string
		verbose        bool
		veryVerbose    bool
		logEncoding    string
		quiet          bool
		pidfile        string
		cpuprofile     string
		memprofile     string
		pprofport      int
		maxMemory      string
		requirePass    string
		adminUser      string
		adminPassword  string
		adminJWTSecret string
	)

	flag.IntVar(&port, "p", getEnvInt("MERIDIAN_PORT", 9851), "The listening port")
	flag.StringVar(&pidfile, "pidfile", "", "A file that contains the pid")
	flag.StringVar(&host, "h", getEnv("MERIDIAN_HOST", ""), "The listening host")
	flag.StringVar(&unixSocket, "s", "", "Listen on a unix socket")
	flag.StringVar(&dir, "d", getEnv("MERIDIAN_DIR", "data"), "The data directory")
	flag.StringVar(&logEncoding, "l", "text", "The log encoding json or text (default: text)")
	flag.BoolVar(&verbose, "v", false, "Enable verbose logging")
	flag.BoolVar(&quiet, "q", false, "Quiet logging. Totally silent")
	flag.BoolVar(&veryVerbose, "vv", false, "Enable very verbose logging")
	flag.IntVar(&pprofport, "pprofport", 0, "pprofport http at port")
	flag.StringVar(&cpuprofile, "cpuprofile", "", "write cpu profile to `file`")
	flag.StringVar(&memprofile, "memprofile", "", "write memory profile to `file`")
	flag.StringVar(&maxMemory, "maxmemory", getEnv("MERIDIAN_MAXMEMORY", ""), "Maximum memory limit (e.g., 1gb, 512mb)")
	flag.StringVar(&requirePass, "requirepass", getEnv("MERIDIAN_REQUIREPASS", ""), "Authentication password")
	flag.StringVar(&adminUser, "admin-user", getEnv("MERIDIAN_ADMIN_USER", ""), "Admin panel username")
	flag.StringVar(&adminPassword, "admin-password", getEnv("MERIDIAN_ADMIN_PASSWORD", ""), "Admin panel password")
	flag.StringVar(&adminJWTSecret, "admin-jwt-secret", getEnv("MERIDIAN_ADMIN_JWT_SECRET", ""), "Admin panel JWT secret")
	flag.Parse()

	if logEncoding == "json" {
		log.SetLogJSON(true)
		data, _ := os.ReadFile(filepath.Join(dir, "config"))
		if gjson.GetBytes(data, "logconfig.encoding").String() == "json" {
			c := gjson.GetBytes(data, "logconfig").String()
			log.Build(c)
		} else {
			log.Build("")
		}
	}

	var logw io.Writer = os.Stderr
	if quiet {
		logw = io.Discard
	}

	log.SetOutput(logw)

	if quiet {
		log.SetLevel(0)
	} else if veryVerbose {
		log.SetLevel(3)
	} else if verbose {
		log.SetLevel(2)
	} else {
		log.SetLevel(1)
	}

	showDebugMessages = veryVerbose

	hostd := ""
	if host != "" {
		hostd = "Addr: " + host + ", "
	}

	// pprof
	if cpuprofile != "" {
		log.Debugf("cpuprofile active")
		f, err := os.Create(cpuprofile)
		if err != nil {
			log.Fatal("could not create CPU profile: ", err)
		}
		if err := pprof.StartCPUProfile(f); err != nil {
			log.Fatal("could not start CPU profile: ", err)
		}
	}
	if memprofile != "" {
		log.Debug("memprofile active")
	}

	var pprofcleanedup bool
	var pprofcleanupMu sync.Mutex
	pprofcleanup := func() {
		pprofcleanupMu.Lock()
		defer pprofcleanupMu.Unlock()
		if pprofcleanedup {
			return
		}
		// cleanup code
		if cpuprofile != "" {
			pprof.StopCPUProfile()
		}
		if memprofile != "" {
			f, err := os.Create(memprofile)
			if err != nil {
				log.Fatal("could not create memory profile: ", err)
			}
			runtime.GC() // get up-to-date statistics
			if err := pprof.WriteHeapProfile(f); err != nil {
				log.Fatal("could not write memory profile: ", err)
			}
			f.Close()
		}
		pprofcleanedup = true
	}
	defer pprofcleanup()

	if pprofport != 0 {
		log.Debugf("pprof http at port %d", pprofport)
		go func() {
			log.Fatal(http.ListenAndServe(fmt.Sprintf(":%d", pprofport), nil))
		}()
	}

	if unixSocket != "" {
		port = 0
	}

	// pid file
	var pidferr error
	var pidcleanedup bool
	var pidcleanupMu sync.Mutex
	pidcleanup := func() {
		if pidfile != "" {
			pidcleanupMu.Lock()
			defer pidcleanupMu.Unlock()
			if pidcleanedup {
				return
			}
			// cleanup code
			if pidfile != "" {
				os.Remove(pidfile)
			}
			pidcleanedup = true
		}
	}
	defer pidcleanup()
	if pidfile != "" {
		os.WriteFile(pidfile, []byte(fmt.Sprintf("%d\n", os.Getpid())), 0666)
	}

	c := make(chan os.Signal, 1)
	shutdown := make(chan bool, 1)

	signal.Notify(c, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
	go func() {
		for s := range c {
			if s == syscall.SIGHUP && nohup {
				continue
			}
			log.Warnf("signal: %v", s)
			pidcleanup()
			pprofcleanup()
			switch {
			default:
				os.Exit(-1)
			case s == syscall.SIGHUP:
				os.Exit(1)
			case s == syscall.SIGINT:
				os.Exit(2)
			case s == syscall.SIGQUIT:
				os.Exit(3)
			case s == syscall.SIGTERM:
				shutdown <- true
			}
		}
	}()

	var saddr string
	if unixSocket != "" {
		saddr = fmt.Sprintf("Socket: %s", unixSocket)
	} else {
		saddr = fmt.Sprintf("Port: %d", port)
	}

	if log.LogJSON() {
		log.Printf(`AIQIA Meridian %s%s %d bit (%s/%s) %s%s, PID: %d`,
			core.Version, gitsha, strconv.IntSize, runtime.GOARCH, runtime.GOOS, hostd, saddr, os.Getpid())
	} else {
		fmt.Fprintf(logw, `
    __  __           _     _ _
   |  \/  | ___ _ __(_) __| (_) __ _ _ __
   | |\/| |/ _ \ '__| |/ _' | |/ _' | '_ \
   | |  | |  __/ |  | | (_| | | (_| | | | |
   |_|  |_|\___|_|  |_|\__,_|_|\__,_|_| |_|

   AIQIA Meridian %s%s %d bit (%s/%s)
   %s%s, PID: %d

`, core.Version, gitsha, strconv.IntSize, runtime.GOARCH, runtime.GOOS, hostd,
			saddr, os.Getpid())
	}

	if pidferr != nil {
		log.Warnf("pidfile: %v", pidferr)
	}
	if showEvioDisabled {
		log.Warnf("evio is not currently supported")
	}
	if showThreadsDisabled {
		log.Warnf("thread flag is deprecated use GOMAXPROCS to set number of threads instead")
	}
	opts := server.Options{
		Host:              host,
		Port:              port,
		Dir:               dir,
		UseHTTP:           httpTransport,
		MetricsAddr:       *metricsAddr,
		UnixSocketPath:    unixSocket,
		DevMode:           devMode,
		ShowDebugMessages: showDebugMessages,
		ProtectedMode:     protectedMode,
		AppendOnly:        appendOnly,
		AppendFileName:    appendFileName,
		QueueFileName:     queueFileName,
		Shutdown:          shutdown,
		Spinlock:          spinlock,
		ClientOutput:      clientOutput,
		MaxMemory:         maxMemory,
		RequirePass:       requirePass,
		AdminUser:         adminUser,
		AdminPassword:     adminPassword,
		AdminJWTSecret:    adminJWTSecret,
	}
	if err := server.Serve(opts); err != nil {
		log.Fatal(err)
	}
}
